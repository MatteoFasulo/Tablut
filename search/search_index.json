{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Tablut Documentation","text":"<p>Welcome to the official documentation for \\tLut, the AI wizard developed by the brilliant minds from the University of Bologna's AI course for the academic year 2023/2024! In this documentation, we'll provide you with a comprehensive understanding of the game of Tablut and how to interact with our enchanting AI creation.</p>"},{"location":"#table-of-contents","title":"Table of Contents","text":"<ol> <li>Introduction</li> <li>Project Philosophy</li> <li>How to Run the Code<ul> <li>Running on Linux</li> <li>Running on Windows</li> </ul> </li> <li>WHITE Heuristics</li> <li>BLACK Heuristics</li> </ol>"},{"location":"#1-introduction","title":"1. Introduction","text":"<p>Tablut is an epic board game with a rich history, and it's the focal point of our AI project. Originating from the tafl family of games, Tablut involves two players - WHITE and BLACK. The WHITE player's objective is to help their king escape to one of the corners of the board, while the BLACK player aims to capture the king. The game unfolds on a square board, and victory depends on strategic moves and careful planning.</p> <p>For a detailed overview of the game, you can refer to the Tablut Wikipedia page.</p>"},{"location":"#2-project-philosophy","title":"2. Project Philosophy","text":"<p>Our is written in Python 3.9, since the most recent AIMA library is not compatible with further versions. We've incorporated the AIMA Python code magic to enhance the enchanting experience. Dive into the source code to explore the intricacies of our implementation and witness the fusion of AI and game strategy.</p>"},{"location":"#3-how-to-run-the-code","title":"3. How to Run the Code","text":"<p>To embark on the magical journey of Tablut with \\tLut, follow these simple steps.</p>"},{"location":"#running-on-linux","title":"Running on Linux","text":"<pre><code>python3 play.py --team WHITE --name \"\\tLut\" --ip &lt;server_ip&gt;\n</code></pre>"},{"location":"#running-on-windows","title":"Running on Windows","text":"<pre><code>py play.py --team WHITE --name \"\\tLut\" --ip &lt;server_ip&gt;\n</code></pre> <p>Adjust the arguments accordingly to choose your team, declare the agent's name, and provide the server's IP address.</p>"},{"location":"1-implementation_details/","title":"Implementation Details","text":"<p>In this section, we delve into the implementation details of the Tablut AI, known as \\tLut. The AI is built upon the Tablut game, a strategic board game with a rich history, and aims to dominate the game using the Minimax algorithm with Alpha-Beta pruning.</p>"},{"location":"1-implementation_details/#game-representation","title":"Game Representation","text":"<p>The game is represented by the <code>Tablut</code> class, which inherits from the AIMA (<code>aima.games.Game</code>) framework. The board itself is represented by the <code>Board</code> class, and various utilities and heuristics are provided by additional classes.</p>"},{"location":"1-implementation_details/#board-initialization","title":"Board Initialization","text":"<p>The <code>Tablut</code> class initializes the game board (<code>Board</code> object) with a default size of 9x9. The initial state includes the board configuration, the current player to move, and the utility value.</p> tablut.py<pre><code>self.initial = Board(height=height, width=width, to_move='WHITE', utility=0)\nself.width = width\nself.height = height\n</code></pre>"},{"location":"1-implementation_details/#game-mechanics","title":"Game Mechanics","text":""},{"location":"1-implementation_details/#updating-game-state","title":"Updating Game State","text":"<p>The <code>update_state</code> method is responsible for updating the state of the board based on the current positions of the pieces and the current turn. In order to reduce the search space, the list of possible moves is computed based on the current player. For example, if it's WHITE's turn, the list of possible moves is computed based on the positions of the WHITE pieces. This approach significantly reduces the number of possible moves, as the BLACK pieces are not considered. Also the list comprehension is used to generate the list of possible moves, which is a more elegant approach than using nested loops.</p> tablut.py<pre><code>def update_state(self, pieces, turn):\n    # Update board state\n    self.initial.pieces = pieces\n    self.initial.to_move = turn\n    self.to_move = turn\n\n    # Update pawns coordinates\n    white_pos = self.initial.get_white()\n    black_pos = self.initial.get_black()\n    king_pos = self.initial.get_king()\n\n    # White has also the king\n    white_pos.insert(0, king_pos)\n\n    # Get the current player and compute the list of possible moves\n    if turn == 'WHITE':\n        self.squares = [[x, (k, l)] for x in white_pos for k in range(\n            self.width) for l in range(self.height)]\n    elif turn == 'BLACK':\n        self.squares = [[x, (k, l)] for x in black_pos for k in range(\n            self.width) for l in range(self.height)]\n</code></pre>"},{"location":"1-implementation_details/#making-moves","title":"Making Moves","text":"<p>The <code>move</code> method is responsible for making a move on the board, given a specific move tuple. It handles the updating of the board state, checks for captures, and changes the turn. In our code, moves are represented as tuples of the form <code>(from_pos, to_pos)</code>, where <code>from_pos</code> and <code>to_pos</code> are tuples of the form <code>(x, y)</code> representing the coordinates of the piece. The <code>move</code> method extracts the starting and ending positions from the move tuple and updates the board accordingly. The <code>check_attacks</code> method is then called to check for captures. Finally, the turn is changed to the opposite player.</p> tablut.py<pre><code>def move(self, move):\n    # Extract the starting and ending position from the move\n    from_pos, to_pos = move\n    x1, y1 = from_pos\n    x2, y2 = to_pos\n\n    pawn_type = self.initial.pieces[x1][y1]\n\n    new_board = copy.deepcopy(self.initial.pieces)\n\n    if pawn_type == Pawn.EMPTY.value or pawn_type == Pawn.THRONE.value:\n        self.initial.pieces = new_board\n        return self\n\n    if self.initial.pieces[x2][y2] != Pawn.EMPTY.value:\n        self.initial.pieces = new_board\n        return self\n\n    # Code to handle movement and captures\n\n    # Check if there are any captures (important for heuristics)\n    self.initial.check_attacks(x2, y2)\n\n    self.initial.pieces = new_board\n\n    # Change turn\n    self.initial.to_move = (\n        \"BLACK\" if self.initial.to_move == \"WHITE\" else \"WHITE\")\n    return self\n</code></pre>"},{"location":"1-implementation_details/#terminal-state-and-victory-conditions","title":"Terminal State and Victory Conditions","text":"<p>The <code>check_win</code> method checks whether the game has reached a terminal state. This includes conditions such as capturing the king (BLACK wins), the king escaping (WHITE wins), a player being unable to move any checker (that player loses), or reaching the same state twice (draw, which is handled by the Java server).</p>"},{"location":"1-implementation_details/#caching-for-improved-performance","title":"Caching for Improved Performance","text":"<p>In order to enhance the efficiency of certain functions within this implementation, a caching mechanism has been implemented using the <code>cache</code> decorator. This decorator is designed to store and retrieve the results of a function based on its arguments. When a function is decorated with <code>cache</code>, the decorator creates an internal cache dictionary. Before executing the original function, the decorator calculates a unique key derived from the function's arguments, specifically focusing on the <code>pieces</code> data (which are represented as a NumPy array). The key is calculated by converting the <code>pieces</code> data to a byte string and storing it in the cache dictionary. The key is then used to check whether the function has been previously executed with the same arguments. This caching strategy significantly optimizes performance by avoiding redundant calculations, especially in scenarios where the function is called with identical input multiple times.</p> <pre><code>def cache(function):\n    \"\"\"\n    A decorator that caches the result of a function based on its arguments.\n\n    Args:\n        function: The function to be cached.\n\n    Returns:\n        The wrapped function that caches the result.\n    \"\"\"\n    cache = {}\n\n    def wrapped(x, *args, **kwargs):\n        pieces = x.pieces.data.tobytes()\n        if pieces not in cache:\n            cache[pieces] = function(x, *args, **kwargs)\n        return cache[pieces]\n    return wrapped\n</code></pre> <p>For example, the <code>max_value</code> and <code>min_value</code> functions are decorated with <code>@cache</code> to avoid redundant calculations of the utility of the board.</p> play.py<pre><code>@cache\ndef max_value(state, alpha, beta, depth, alpha0, beta0, gamma0, theta0, epsilon0, action_backtrack=None):\n    ...\n\n@cache\ndef min_value(state, alpha, beta, depth, alpha0, beta0, gamma0, theta0, epsilon0, action_backtrack=None):\n    ...\n</code></pre>"},{"location":"2-heuristics/","title":"Heuristics","text":"<p>The heuristics for both the WHITE and BLACK players are implemented in separate modules (<code>whiteheuristics.py</code> and <code>blackheuristics.py</code>). These heuristics assess the current state of the board and contribute to the overall fitness of the position for each player: the higher the fitness, the more favorable the move is for the player. </p> <p>In order to determine the fitness of a position, the heuristics are weighted and summed together. The weights are the result of the execution of <code>genetic.py</code>. The weights are not optimal, but they are good enough to provide a decent performance of the AI. A more in detail description of how the genetic algorithm works can be found in Genetic Algorithm for Weight Fine-Tuning.</p> WHITE Heuristics <p>The WHITE player's heuristics include factors such as:</p> <ol> <li>Number of white pieces     <ul> <li>The more the white pieces are, the more the heuristic value increases</li> </ul> </li> <li>Number of black pieces     <ul> <li>The more the black pieces are, the more the heuristic value decreases</li> </ul> <li>Distance of the king from the centre     <ul> <li>The more the king is distant from the centre, the more the heuristic value increases</li> <li>The euclidean distance is used for this heuristic</li> </ul> </li> <li>King sorrounded by black pieces     <ul> <li>If the king is sorrounded by black pieces, the heuristic value decreases</li> </ul> </li> <li>Weights of each position of the board     <ul> <li>Each position of the board has a weight, which is used to calculate the heuristic value</li> <li>The winning positions are very heavy</li> <li>The positions in which the white pawns cannot go to have negative weight</li> </ul> </li> BLACK Heuristics <p>The BLACK player's heuristics include factors such as:</p> <ol> <li>Number of black pieces     <ul> <li>The more the black pieces are, the more the heuristic value increases</li> </ul> </li> <li>Number of white pieces     <ul> <li>The less the white pieces are, the more the heuristic value decreases</li> </ul> <li>Number of black pawns close to the king     <ul> <li>The closer are the black pawns to the king, the more the fitness value is increased </li> </ul> </li> <li>Free paths to the king     <ul> <li>It counts how many direct path from any black pawn to the king exists. The fitness increases linearly to the number of paths</li> </ul> </li> <li>Encirclement coefficient to the king     <ul> <li>A coefficient that measures how much the king is encricled. Clearly the fitness is higher when the king is a lot encircled</li> </ul> </li>"},{"location":"3-genetic_algorithms/","title":"VERY IMPORTANT NOTICE","text":"<p>running the program as it is now will not execute correctly, since the weights are now assigned statically. The file that has been kept in the repository must be interpreted as read-only</p>"},{"location":"3-genetic_algorithms/#genetic-algorithm-for-refining-ai-weights","title":"Genetic Algorithm for Refining AI Weights","text":"<p>Within this section, we delve into the intricacies of employing a genetic algorithm to fine-tune the weights of an artificial intelligence system within the specific domain of Tablut gameplay. The primary objective of this algorithm is to iteratively evolve a population of weight sets, refining the AI's performance over time. These weights serve as crucial hyperparameters for the associated heuristics.</p>"},{"location":"3-genetic_algorithms/#concise-overview-of-the-algorithm","title":"Concise Overview of the Algorithm","text":"<p>Genetic algorithms, commonly applied in optimization scenarios, found utility in our context by framing an optimization problem around Tablut matches. This involved formulating a fitness function, which, given a match with a set of hyperparameters and the count of moves required for victory, yields a value denoted as N.</p> genetic.py<pre><code>def fitness(turns):\n    return 30 - turns\n</code></pre> <p>The algorithm's primary objective is to maximize the derived value N. Notably, 30 represents the maximum allowable moves per game, and if the game extends beyond this limit, the fitness is constrained to -1.</p>"},{"location":"3-genetic_algorithms/#algorithmic-workflow","title":"Algorithmic Workflow","text":"<p>Initiating with a starting population of hyperparameters comprising 10 tuples, the algorithm orchestrates 10 games, recording the move count for each victory. Subsequently, it calculates a new population by selecting the best-performing elements and subjecting them to mutations. Noteworthy is the inclusion of two entirely random elements in each population, strategically introduced to mitigate the risk of converging into a local minimum.</p>"},{"location":"3-genetic_algorithms/#genetic-algorithm-components","title":"Genetic Algorithm Components","text":""},{"location":"3-genetic_algorithms/#crossover","title":"Crossover","text":"<p>The <code>cross_chromosome</code> function performs crossover between two parent chromosomes, generating two new chromosomes.</p> genetic.py<pre><code>def cross_chromosome(chromosome1, chromosome2):\n    alpha0, beta0, gamma0, theta0, epsilon0 = chromosome1\n    alpha1, beta1, gamma1, theta1, epsilon1 = chromosome2\n    new_chromosome1 = [alpha0, beta1, gamma0, theta1, epsilon0]\n    new_chromosome2 = [alpha1, beta0, gamma1, theta0, epsilon1]\n    return new_chromosome1, new_chromosome2\n</code></pre>"},{"location":"3-genetic_algorithms/#mate-selection","title":"Mate Selection","text":"<p>The <code>mate</code> function randomly selects two chromosomes from the population and creates a new chromosome through averaging their values.</p> genetic.py<pre><code>def mate(elements):\n    random1 = copy.deepcopy(random.choice(elements))\n    random2 = copy.deepcopy(random.choice(elements))\n\n    alpha0, beta0, gamma0, theta0, epsilon0 = random1\n    alpha1, beta1, gamma1, theta1, epsilon1 = random2\n\n    new_chromosome = [(alpha0+alpha1)/2, (beta0+beta1)/2, (gamma0+gamma1)/2, (theta0+theta1)/2, (epsilon0+epsilon1)/2]\n    return new_chromosome\n</code></pre>"},{"location":"3-genetic_algorithms/#mutation","title":"Mutation","text":"<p>The <code>mutate</code> function introduces random mutations to the population, affecting the weights of each chromosome.</p> genetic.py<pre><code>def mutate(population, mutation_rate=0.6):\n    for i in range(1, len(population)):\n        if random.random() &lt; mutation_rate:\n            alpha, beta, gamma, theta, epsilon = population[i]\n            alpha += random.uniform(-1, 1)\n            beta += random.uniform(-1, 1)\n            gamma += random.uniform(-1, 1)\n            theta += random.uniform(-1, 1)\n            epsilon += random.uniform(-1, 1)\n            population[i] = [alpha, beta, gamma, theta, epsilon]\n    return population\n</code></pre>"},{"location":"3-genetic_algorithms/#population-initialization","title":"Population Initialization","text":"<p>The <code>create_starting_population</code> function initializes the population with random chromosomes.</p> genetic.py<pre><code>def create_starting_population(elements=10):\n    population = []\n    for i in range(elements):\n        population.append([random.uniform(0, 2), random.uniform(0, 2), random.uniform(0, 10), random.uniform(0, 2), random.uniform(0, 3)])\n    return population\n</code></pre>"},{"location":"3-genetic_algorithms/#main-loop","title":"Main Loop","text":"<p>The genetic algorithm iterates over a predefined number of generations, evaluating the fitness of each chromosome in the population by playing games. The top-performing chromosomes are selected for crossover, mating, and mutation to produce the next generation.</p> genetic.py<pre><code>iterations = 50\nelements = 10\nmax_moves = 30\ncod = cutoff_depth(2)\npopulation = create_starting_population(elements)\n\nfor iteration in range(iterations):\n    results = []\n    for pop in population:\n        # Play a game with the current chromosome\n        alpha0, beta0, gamma0, theta0, epsilon0 = pop\n        result, turns = play_game(alpha0, beta0, gamma0, theta0, epsilon0, cod, max_moves, name=\"Player\", team=sys.argv[1], server_ip=\"127.0.0.1\", timeout=60)\n        if result == 0:\n            results.append([pop, fitness(turns)])\n        else:\n            results.append([pop, -1])\n        time.sleep(5)\n\n    # Sort results by fitness in descending order\n    results = sorted(results, key=lambda x: x[1], reverse=True)\n\n    # Print and record the best fitness and parameters\n    print(\"Generation:\", iteration)\n    print(\"Best fitness:\", results[0][1])\n    print(\"Best parameters:\", results[0][0])\n\n    with open(\"results.txt\", \"a\") as f:\n        f.write(\"Generation: \" + str(iteration) + \"\\n\")\n        f.write(\"Best fitness: \" + str(results[0][1]) + \"\\n\")\n        f.write(\"Best parameters: \" + str(results[0][0]) + \"\\n\\n\")\n\n    # Create a new population for the next generation\n    new_population = [copy.deepcopy(results[0][0])]\n\n    # Crossover the top-performing chromosomes\n    e1, e2 = cross_chromosome(results[0][0], results[1][0])\n    new_population.extend([e1, e2])\n    e1, e2 = cross_chromosome(results[0][0], results[2][0])\n    new_population.extend([e1, e2])\n\n    # Mate from the top 5 elements to create the remaining-3 elements\n    top_five = copy.deepcopy(results[:5])\n    random.shuffle(top_five)\n    top_five = [x[0] for x in top_five]\n    new_population.extend([mate(top_five) for _ in range(3)])\n\n    # Add three random elements\n    new_population.extend([create_random_chromosome() for _ in range(2)])\n\n    # Mutate everything except the first element\n    new_population = mutate(new_population)\n\n    # Update the population for the next generation\n    population = copy.deepcopy(new_population)\n</code></pre>"},{"location":"4-alpha-beta/","title":"Alpha-Beta","text":"<p>This section will talk about the implementation of the <code>Alpha-Beta</code> search algorithm.</p>"},{"location":"4-alpha-beta/#pruning","title":"Pruning","text":"<p>In this project it has been used a particular implementation of Alpha-beta <code>pruning</code> in a <code>minmax</code> context.  Alpha-beta pruning is a search algorithm that aims to reduce the number of nodes evaluated by the minmax algorithm in its search tree. This algorithm stops evaluating a move as soon as it finds at least one possibility that proves the move to be worse than a previously examined move. Such moves do not need to be evaluated further. When applied to a standard minimax tree, alpha-beta pruning returns the same move as minmax would, but it prunes away branches that cannot possibly influence the final decision.</p>"},{"location":"4-alpha-beta/#cutoff","title":"Cutoff","text":"<p>The cutoff_depth function is a cutoff function that stops the search if it reaches a certain <code>depth</code> d. This is used to limit the search space and make the algorithm more efficient. A depth of 2 is the perfect compromise when it comes to saving computational time and creating a competent agent.</p> cutoff_depth<pre><code>def cutoff_depth(d):\n    \"\"\"A cutoff function that searches to depth d.\"\"\"\n    return lambda game, state, depth: depth &gt; d\n</code></pre>"},{"location":"4-alpha-beta/#minmax","title":"MinMax","text":"<p>The <code>max_value</code> and <code>min_value</code> functions are the core of the Alpha-Beta search algorithm. They represent the two players (<code>black</code> and <code>white</code>) in the game, with <code>max_value</code> being the active turn player, trying to maximize the score, and <code>min_value</code> being the other player, trying to minimize the score.</p> <p>This simulates a position where every single player will make the perfect move to maximize their future score, considering that the other player will try to do the same.</p>"},{"location":"4-alpha-beta/#max","title":"Max","text":"<p>Here we see the code of maxvalue:</p> maxvalue<pre><code>def max_value(state, alpha, beta, depth):\n        nonlocal best_move\n        if game.terminal_test(state):\n            return game.utility(state, player), None\n        if cutoff(game, state, depth):\n            v = game.compute_utility(state, None, player)\n            return v, None\n        if time.time() - start_time &gt; time_limit:\n            print(f\"TIMEOUT at {depth = }, player: {player}\")\n            raise TimeoutError(best_move)\n        v, move = -np.inf, None\n        for a in game.actions(state):\n            v2, _ = min_value(game.result(state, a), alpha, beta, depth+1)\n            if v2 &gt; v:\n                v, move = v2, a\n                alpha = max(alpha, v)\n            if v &gt;= beta:\n                return v, move\n        return v, move\n</code></pre> <p>The function takes four parameters: <code>state</code>, <code>alpha</code>, <code>beta</code>, and <code>depth</code>.<code>state</code> represents the current state of the game. <code>alpha</code> and <code>beta</code> are the best values that the players can, respectively, guarantee at that level or above. <code>depth</code> is the current depth of the search.</p> <p>The function first checks if the current state is a terminal state or if the cutoff depth has been reached. If either of these conditions are true, it computes the utility of the state and returns it. If not, it iterates over all possible actions, calls <code>min_value</code> for the result of each action, and updates the maximum value <code>v</code> and the corresponding move if the returned value is greater than the current maximum value. It also updates the <code>alpha</code> value.</p> <p>If the maximum value <code>v</code> is greater than or equal to the beta value, the function prunes the remaining branches and returns the maximum value and the corresponding move. This is because the minimizing player will never choose this branch as it already has a better option.</p>"},{"location":"4-alpha-beta/#min","title":"Min","text":"<p>The <code>min_value</code> function works similarly, but it represents the minimizing player and tries to minimize the value. It updates the beta value and prunes the remaining branches if the minimum value is less than or equal to the alpha value.</p> minvalue<pre><code>def min_value(state, alpha, beta, depth):\n        nonlocal best_move\n        if game.terminal_test(state):\n            return game.utility(state, player), None\n        if cutoff(game, state, depth):\n            v = game.compute_utility(state, None, player)\n            return v, None\n        if time.time() - start_time &gt; time_limit:\n            print(f\"TIMEOUT at {depth = }, player: {player}\")\n            raise TimeoutError(best_move)\n        v, move = +np.inf, None\n        for a in game.actions(state):\n            v2, _ = max_value(game.result(state, a), alpha, beta, depth + 1)\n            if v2 &lt; v:\n                v, move = v2, a\n                beta = min(beta, v)\n            if v &lt;= alpha:\n                return v, move\n        return v, move\n</code></pre> <p>These functions are recursive, calling each other until the tree at the chosen depth as been explored or time runs out.</p>"},{"location":"4-alpha-beta/#timeout","title":"Timeout","text":"<p>If the time spent exceeds the time limit, both functions raise a <code>TimeoutError</code> with the best move found so far.</p> timeoutError<pre><code>if time.time() - start_time &gt; time_limit:\n            print(f\"TIMEOUT at {depth = }, player: {player}\")\n            raise TimeoutError(best_move)\n</code></pre> <p>This code snippet initiates the Alpha-Beta search algorithm by calling the <code>max_value</code> function. It tracks the start time for handling timeouts. If a <code>TimeoutError</code> occurs, it retrieves the best move found so far from the exception and returns it. Otherwise, it returns the best move found by the algorithm.</p> start-timer<pre><code>    start_time = time.time()\n    try:\n        result = max_value(state, -np.inf, +np.inf, 0)[-1]\n    except TimeoutError as e:\n        result = e.args[0]\n    return result\n</code></pre>"},{"location":"5-network/","title":"Networking and Game State Handling","text":"<p>The provided code establishes a network connection and handles the conversion of game states between JSON and matrix representations.</p> <p>This includes classes for network communication (<code>Network</code>) and a converter (<code>Converter</code>) to facilitate the transformation between JSON and matrix formats. In order to map each pawn type to a specific value, a set of constants has been defined. The <code>Pawn</code> enumeration defines different pawn types, including <code>EMPTY</code>, <code>WHITE</code>, <code>BLACK</code>, <code>KING</code>, and <code>THRONE</code> allowing to easily identify the type of each pawn while fetching the game state. Key components of the implementation are as follows:</p>"},{"location":"5-network/#networking-functionality","title":"Networking Functionality","text":"<p>The <code>Network</code> class manages the network communication between the game client and server. It supports connection setup, sending moves, and receiving the current game state. It utilizes socket programming and JSON encoding/decoding for data exchange. The <code>connect</code> method establishes a connection with the server, and the <code>get_state</code> method retrieves the current game state.</p>"},{"location":"5-network/#game-state-conversion","title":"Game State Conversion","text":"<p>The <code>Converter</code> class handles the conversion between JSON representations received from the server and the matrix format used in the code. It provides the <code>json_to_matrix</code> method, converting the JSON state into a 9x9 matrix representing the game board. This method uses the <code>Pawn</code> enumeration to map each pawn type to a specific value by using a numpy method called <code>vectorize</code> which applies a lambda function to each element of the board. The lambda function maps each pawn type to a specific value, as shown below:</p> utils.py<pre><code>class Converter:\n    def json_to_matrix(self, json_state):\n        data = list(json_state.items())\n        board, turn = data[0], data[1]\n\n        if isinstance(board, tuple):\n            board = board[1]\n\n        if isinstance(turn, tuple):\n            turn = turn[1]\n\n        board = np.vectorize(lambda x: Pawn[x].value)(board)\n        board = board.reshape(9, 9)\n\n        return board, turn\n</code></pre>"},{"location":"5-network/#game-state-fetching","title":"Game State Fetching","text":"<p>The <code>get_state</code> method of the <code>Network</code> class is responsible for fetching the current game state from the server and checks the returned state for validity. If the turn is not neither <code>WHITE</code> nor <code>BLACK</code>, the method returns <code>WHITEWIN</code>, <code>BLACKWIN</code>, or <code>DRAW</code> depending on the outcome of the game which is calculated by the Java server.</p> utils.py<pre><code>def get_state(self):\n        len_bytes = struct.unpack('&gt;i', self.recvall(4))[0]\n        current_state_server_bytes = self.sock.recv(len_bytes)\n\n        # Converting byte into json\n        json_current_state_server = json.loads(current_state_server_bytes)\n\n        state, turn = self.converter.json_to_matrix(json_current_state_server)\n\n        if not turn in ['WHITEWIN', 'BLACKWIN', 'DRAW']:\n\n            self.turn = turn\n            self.state = state\n\n            return state, turn\n\n        else:\n            if turn == 'WHITEWIN':\n                return 0, \"WHITE WINS!\"\n                sys.exit(0)\n\n            elif turn == 'BLACKWIN':\n                return 1, \"BLACK WINS!\"\n                sys.exit(0)\n\n            elif turn == 'DRAW':\n                return 2, \"DRAW!\"\n                sys.exit(0)\n</code></pre>"}]}